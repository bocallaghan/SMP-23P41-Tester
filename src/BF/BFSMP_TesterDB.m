
/* Copyright (c) Sybase, Inc. 2010-2013   All rights reserved.
 
 In addition to the license terms set out in the Sybase License Agreement for
 the Sybase Unwired Platform ("Program"), the following additional or different
 rights and accompanying obligations and restrictions shall apply to the source
 code in this file ("Code").  Sybase grants you a limited, non-exclusive,
 non-transferable, revocable license to use, reproduce, and modify the Code
 solely for purposes of (i) maintaining the Code as reference material to better
 understand the operation of the Program, and (ii) development and testing of
 applications created in connection with your licensed use of the Program.
 The Code may not be transferred, sold, assigned, sublicensed or otherwise
 conveyed (whether by operation of law or otherwise) to another party without
 Sybase's prior written consent.  The following provisions shall apply to any
 modifications you make to the Code: (i) Sybase will not provide any maintenance
 or support for modified Code or problems that result from use of modified Code;
 (ii) Sybase expressly disclaims any warranties and conditions, express or
 implied, relating to modified Code or any problems that result from use of the
 modified Code;OT BE LIABLE FOR ANY LOSS OR DAMAGE RELATING
 TO MODIFICATIONS MADE TO THE CODE OR FOR ANY DAMAGES RESULTING FROM USE OF THE
 MODIFIED CODE, INCLUDING, WITHOUT LIMITATION, ANY INACCURACY OF DATA, LOSS OF
 PROFITS OR DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES, EVEN
 IF SYBASE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES;
 to indemnify, hold harmless, and defend Sybase from and against any claims or
 lawsuits, including attorney's fees, that arise from or are related to the
 modified Code or from use of the modified Code.
 
 */

/*
 Generated by Sybase Unwired Platform 
 Compiler version - 2.3.4.285
*/ 

#import "BFSMP_TesterDB.h"
#import "BFSMP_TesterDB+Internal.h"

#import "BFLST_MBO1.h"
#import "BFLST_MBO1+Internal.h"
#import "BFLogRecordImpl.h"
#import "BFLogRecordImpl+Internal.h"
#import "BFOperationReplay.h"
#import "BFOperationReplay+Internal.h"
#import "BFSISSubscriptionKey.h"
#import "BFSISSubscriptionKey+Internal.h"
#import "BFSISSubscription.h"
#import "BFSISSubscription+Internal.h"
#import "BFPackageProperties.h"
#import "BFPackageProperties+Internal.h"
#import "BFChangeLogKey.h"
#import "BFChangeLogKey+Internal.h"
#import "BFChangeLogImpl.h"
#import "BFChangeLogImpl+Internal.h"
#import "BFOfflineAuthentication.h"
#import "BFOfflineAuthentication+Internal.h"
#import "BFKeyPackageName.h"
#import "BFKeyPackageName+Internal.h"
#import "BFPersonalizationParameters.h"
#import "BFPersonalizationParameters+Internal.h"
#import "BFKeyGenerator.h"
#import "BFKeyGenerator+Internal.h"
#import "BFLocalKeyGenerator.h"
#import "BFLocalKeyGenerator+Internal.h"
#import "MBODebugLogger.h"
#import "SUPEntityMessageListener.h"
#import "SUPStringList.h"
#import "SUPJsonObject.h"
#import "SUPQueueConnectionImpl.h"
#import "SUPMessageLiterals.h"
#import "BFLoggerImpl.h"
#import "SUPJsonString.h"
#import "SUPEntityMap.h"
#import "SUPClassMap.h"
#import "SUPSynchronizationAction.h"
#import "SUPSynchronizationGroup.h"
#import "SUPSynchronizationContext.h"
#import "SUPSynchronizationStatus.h"
#import "SUPDatabaseDelegate.h"
#import "SUPResultSetWrapper.h"
#import "SUPAbstractDBRBS.h"
#import "SUPAbstractPersonalizationParameters.h"
#import "SUPDatabaseManagerFactory.h"

@interface BFSMP_TesterDB(hidden)
- (id)init;
- (id)initWithName:(NSString*)name;
// singleton
+ (BFSMP_TesterDB*)instance;
+ (id)allocWithZone:(NSZone *)zone;
- (id)copyWithZone:(NSZone *)zone;
- (id)retain;
- (NSUInteger)retainCount;
- (void)release;
- (id)autorelease;
- (void)defineMessageListenerForEntity:(NSString*)entityName withClass:(Class)entityClass;
- (NSString*)packageVersionedPrefix;
- (BOOL)checkPending_LogRecordImpl;
- (BOOL)checkPending_PackageProperties;
- (BOOL)checkAllReplayPending;
- (void)writeLogFromHeader:(SUPJsonObject*)o :(SUPNullableString)mbo :(SUPNullableString)method;
- (NSString *)ppmHeader;
+ (void)waitForKeyGenerator;
@end
@implementation BFSMP_TesterDB



#pragma mark -
#pragma mark Init, dealloc, getInstance
- (id)init
{
    return [self initWithName:@"sMP_Tester1_0"];
}

- (id)initWithName:(NSString*)name;
{
    if ((self = [super initWithName:name]))
    {
        // self.manager = (NSObject<SUPDatabaseManagerRBS>*)[SUPDatabaseManagerFactory dbManagerOfType:SUPDatabaseManager_UltraLite];
    	self->_concreteSubclass = [self class];
    	
   	    [self defineMessageListenerForEntity:@"LST_MBO1" withClass:[BFLST_MBO1 class]];
   	    [self defineMessageListenerForEntity:@"LogRecordImpl" withClass:[BFLogRecordImpl class]];
   	    [self defineMessageListenerForEntity:@"OperationReplay" withClass:[BFOperationReplay class]];
   	    [self defineMessageListenerForEntity:@"SISSubscription" withClass:[BFSISSubscription class]];
   	    [self defineMessageListenerForEntity:@"PackageProperties" withClass:[BFPackageProperties class]];
   	    [self defineMessageListenerForEntity:@"ChangeLogImpl" withClass:[BFChangeLogImpl class]];
   	    [self defineMessageListenerForEntity:@"OfflineAuthentication" withClass:[BFOfflineAuthentication class]];
   	    [self defineMessageListenerForEntity:@"KeyGenerator" withClass:[BFKeyGenerator class]];

    	// set the logger
    	[self setLogger:[[[BFLoggerImpl alloc] init] autorelease]];
        //self.pid = [NSString stringWithFormat:@"moca://%@", [SUPMessageClient getDeviceID]];
        [self.connectionProfile setPageSize:1024];
        SUPConnectionProfile *sp = [self.connectionProfile syncProfile];
        [sp setString:@"domainName":@"bf"];
        [sp setString:@"mlHost":@"WIN-57C9428FHMV"];
        [sp setInt:@"mlPort":2480];
        [sp setString:@"mlStreamType":@"http,https"];
        [sp setString:@"mlStreamParams":@"trusted_certificates="];
        [sp setString:@"mlUrlSuffix":@"url_suffix="];
        [sp remove:@"upa"];
        [sp applyPropertiesFromApplication];
 	}

    return self;
    
}
- (void)dealloc
{
	[super dealloc];
}

#pragma mark -
#pragma mark Singleton implementation

static BFSMP_TesterDB *instance = nil;
 
+ (BFSMP_TesterDB*)instance
{
    @synchronized(self) {
        if (instance == nil) {
            // Singleton is never released
            instance = [[super allocWithZone:NULL] init];
        }
    }
    return instance;
}

+ (id) designateObjectForRetain: (id)obj NS_RETURNS_RETAINED
{
    return obj;
}
+ (id)allocWithZone:(NSZone *)zone
{
    return [self designateObjectForRetain:[self instance]];
}
- (id)copyWithZone:(NSZone *)zone
{
    return self;
}
 
- (id)retain
{
    return self;
}
 
- (NSUInteger)retainCount
{
    return NSUIntegerMax;  //denotes an object that cannot be released
}
 
- (oneway void)release
{
    //do nothing
}
 
- (id)autorelease
{
    return self;
}

#pragma mark -
#pragma mark Initialize and delegate methods (internal)

+ (void)initialize
{
	[self metaData];
	[self delegate];
}

static SUPDatabaseDelegate *g_BFSMP_TesterDB_delegate = nil;

+ (SUPDatabaseDelegate *) delegate
{
	@synchronized(self) {
		if (g_BFSMP_TesterDB_delegate == nil) {
			g_BFSMP_TesterDB_delegate = [[SUPDatabaseDelegate alloc] initWithDatabase:[self instance]];
		}
	}
	
	return [[g_BFSMP_TesterDB_delegate retain] autorelease];
}

#pragma mark -
#pragma mark Methods to retrieve package name, username, etc.

- (NSString*)packageVersionedPrefix
{
	return @"SMP_Tester:1.0";
}

- (NSString*)syncParamsVersion
{
    return [NSString stringWithFormat:@"%@_smp_tester.1_0", [[self class] getDomainName]];
}

+ (NSString*)getSyncUsername
{
    return [[self delegate] getSyncUsername];
}

+ (NSString*)getPackageName
{
	return [[self instance] packageVersionedPrefix];
}

+ (NSString*)getDomainName
{
	return [[self delegate] getDomainName];
}

+ (NSString*)defaultDomainName
{
	return @"bf";
}

+ (int32_t)getSchemaVersion
{
	return [[self delegate] getSchemaVersion];
}

+ (int32_t)getProtocolVersion
{
    return 4;
}

#pragma mark -
#pragma mark Metadata methods

static SUPDatabaseMetaDataRBS* BFSMP_TesterDB_META_DATA;
static BOOL _valid_ = NO;

+ (SUPDatabaseMetaDataRBS*)metaData
{
    if (! (_valid_))
    {
		BFSMP_TesterDB_META_DATA = [[BFSMP_TesterDBMetaData alloc] init];
     	_valid_ = YES;
	}
	
	return BFSMP_TesterDB_META_DATA;
}

#pragma mark -
#pragma mark Personalization methods

+ (BFPersonalizationParameters*)getPersonalizationParameters
{
    return (BFPersonalizationParameters*)( ((SUPDatabaseDelegate *)[self delegate]).personalizationParameters);
}

#pragma mark -
#pragma mark Log methods

+ (SUPObjectList*)getLogRecords:(SUPQuery*)query
{
	// If query is nil, create an empty one and findWithQuery will get all the records
	if(query == nil)
		query = [SUPQuery getInstance];
    return (SUPObjectList*)[BFLogRecordImpl findWithQuery:query];
}

+ (void)submitLogRecords
{
    [BFLogRecordImpl submitPendingOperations];
}

+ (void)writeLogFromHeader:(SUPJsonObject*)o :(SUPNullableString)mbo :(SUPNullableString)method
{
#if 0
	// if server sent level attribute as string, change it to integer before reading JSON
	id levelObject = [o item:@"level"];
    if (((levelObject != nil)) && ([levelObject isKindOfClass:[SUPJsonString class]]))
    {
        SUPJsonString* js = ((SUPJsonString*)(levelObject));
        [o setInt:@"level":[SUPLogLevel fromString:js.value]];
    }
	BFLogRecordImpl *log = [[BFLogRecordImpl alloc] initFromJson:o :0];
	if (!([o containsKey:@"messageId"]))
	{
		SUPObjectList *klist = [BFKeyGenerator findAll];
		if([klist size] > 0)
			log.messageId = [BFKeyGenerator generateId];
		else
			log.messageId = [BFLocalKeyGenerator generateId];
	}
	if(log.component == nil) log.component = ((mbo != nil) ? mbo : @"SMP_TesterDB");
	if(log.operation == nil) log.operation = method;
	if(log.requestId == nil) log.requestId = [NSString stringWithFormat:@"%ld",log.messageId];
	if(log.timestamp == nil) log.timestamp = [[NSDate alloc] initWithTimeIntervalSinceNow:0];
	[log createPending:NO];
	[log autorelease];
#endif
}

#pragma mark -
#pragma mark Public database class methods

+ (SUPLocalTransaction*)beginTransaction
{
    return [super beginTransaction];
}

+ (NSObject<SUPCallbackHandler>*)callbackHandler
{
    return [[self instance] callbackHandler];
}

+ (SUPConnectionProfile*)connectionProfile
{
    return [[self instance] connectionProfile];
}

+ (SUPConnectionProfile*)getConnectionProfile
{
    return [[self instance] connectionProfile];
}

+ (SUPConnectionProfile*)getSynchronizationProfile
{
    return [[[self instance] connectionProfile] syncProfile];
}

+ (void)createDatabase
{
    [[BFSMP_TesterDB delegate] createDatabase];
}

+ (void)deleteDatabase
{
    [super deleteDatabase];
}

+ (BOOL)databaseExists
{
    return [super databaseExists];
}

+ (id<SUPConnectionWrapper>)getConnectionWrapper
{
    return [super getConnectionWrapper];
}

+ (void)openConnection
{
    [self getConnectionWrapper];
}

+ (void)closeConnection
{
    [super closeConnection];
    [[self instance] setManager:nil];
}

+ (id<SUPLogger>)getLogger
{
	return [[self instance] logger];
}

+ (id<SUPSynchronizationGroup>) getSynchronizationGroup:(NSString*)syncGroup
{
    return [g_BFSMP_TesterDB_delegate getSynchronizationGroup:syncGroup];
}

+ (BOOL)isSynchronized:(NSString*)syncGroup
{
    return [g_BFSMP_TesterDB_delegate isSynchronized:syncGroup];
}

+ (NSDate*)getLastSynchronizationTime:(NSString*)syncGroup
{
    return [g_BFSMP_TesterDB_delegate getLastSynchronizationTime:syncGroup];
}

+ (SUPQueryResultSet*)executeQuery:(SUPQuery*)query
{
	return [super executeQuery:[self metaData] query:query];
}

+ (void)registerCallbackHandler:(NSObject<SUPCallbackHandler>*)handler
{
    [super registerCallbackHandler:handler];
}

+ (void)setApplication:(SUPApplication*)application
{
    [[self instance] startBackgroundSynchronization];
}

+ (void)submitPendingOperations
{
	[self submitPendingOperations:nil];
}

+ (void)submitPendingOperations:(NSString*)synchronizationGroup
{
	[[BFSMP_TesterDB delegate] submitPendingOperations:synchronizationGroup];
}

+ (void)cancelPendingOperations
{
	[self cancelPendingOperations:nil];
}

+ (void)cancelPendingOperations:(NSString*)synchronizationGroup
{
	[[BFSMP_TesterDB delegate] cancelPendingOperations:synchronizationGroup];
}

+ (void)subscribe
{
	[[self delegate] subscribe];
}

+ (void)beginSynchronize:(SUPObjectList*)synchronizationGroups withContext:(NSString*)context withUploadOnly:(BOOL) uploadOnly withSyncStatusListener:(id<SUPSyncStatusListener>)listener
{
	[[self delegate] beginSynchronizeForGroups:synchronizationGroups withContext:context withUploadOnly:uploadOnly withSyncStatusListener:listener];
}

+ (void)beginSynchronize:(SUPObjectList*)synchronizationGroups withContext:(NSString*)context withUploadOnly:(BOOL) uploadOnly
{
	[[self delegate] beginSynchronizeForGroups:synchronizationGroups withContext:context withUploadOnly:uploadOnly];
}

+ (void)beginSynchronize:(SUPObjectList*)synchronizationGroups withContext:(NSString*)context;
{
	[[self delegate] beginSynchronizeForGroups:synchronizationGroups withContext:context];
}

+ (BOOL)resumePendingSynchronization
{
    return [[self delegate]resumePendingSynchronization];
}

+ (BOOL)cancelPendingSynchronization
{
    return [[self delegate]cancelPendingSynchronization];
}

+ (void)unsubscribe
{
    [[self delegate] unsubscribe];
}

+ (BOOL)hasPendingOperations
{
	return [[self instance] checkAllReplayPending];
}

+ (void)synchronize
{
    
	[[self delegate] synchronize];
}
+ (void)synchronize:(NSString*)synchronizationGroup
{
    [[self delegate] synchronize:synchronizationGroup];
}
+ (void)synchronizeWithListener:(id<SUPSyncStatusListener>) listener
{
    [[self delegate] synchronizeWithListener:listener];
}
+ (void)synchronize:(NSString *)synchronizationGroup withListener:(id<SUPSyncStatusListener>)listener
{
    [[self delegate] synchronize:synchronizationGroup withListener:listener];
}

+ (void)enableSync
{
    [super enableSync];
}

+ (void)disableSync
{
    [super disableSync];
}

+ (BOOL)syncEnabled
{
    return [super syncEnabled];
}

+ (SUPOnlineLoginStatus*)getOnlineLoginStatus
{
	
	[self doesNotRecognizeSelector:_cmd];
	return nil;
	// this is for MBS
	//return [[self instance] onlineLoginStatus];
}

+ (void)generateEncryptionKey
{
    [super generateEncryptionKey];
}

+ (void)changeEncryptionKey:(NSString *)newKey
{
    [super changeEncryptionKey:newKey];
}

+ (void)cleanAllData:(BOOL) keepClientOnly
{
	[[self delegate] cleanAllData:keepClientOnly];
}

+ (void)cleanAllData
{
	[[self delegate] cleanAllData];
}

+ (BOOL) isReplayQueueEmpty
{
	return [[self delegate] isReplayQueueEmpty];
}
+ (SUPObjectList*) getBackgroundSyncRequests
{
	return [[self delegate] getBackgroundSyncRequests];
}

+ (void) enableChangeLog
{
    [[self getSynchronizationProfile] setString:@"changeLogEnabled":@"true"];
}

+ (void) disableChangeLog
{
    [[self getSynchronizationProfile] setString:@"changeLogEnabled":@"false"];
}

+ (SUPObjectList*) getChangeLogs:(SUPQuery*)query
{
   return [[self delegate] getChangeLogs:query];
}

+ (void) deleteChangeLogs
{
    return [BFChangeLogImpl deleteChangeLogs];
}

+ (NSString*) getEntityName:(int)entityType
{
    switch (entityType)
    {
        default: return nil;
    }
}

+ (void) onlineLogin
{
    SUPConnectionProfile *sp = [self getSynchronizationProfile];
    [sp applyPropertiesFromApplication];
    NSString *username = [sp getUser];
    NSString *password = [sp getPassword];
    [[self delegate] onlineLogin:username password:password];   
}
+ (void) createIndex:(SUPIndexMetaData *)index withEntity:(SUPEntityMetaDataRBS *)entity
{
    [[self delegate] createIndex:index withEntity:entity];
}

+ (void) dropIndex:(NSString*)name withEntity:(SUPEntityMetaDataRBS *)entity
{
    [[self delegate] dropIndex:name withEntity:entity];
}

+ (SUPObjectList*) getIndexes:(SUPEntityMetaDataRBS *)entity
{
    return [[self delegate] getIndexes:entity];
}

#pragma mark -
#pragma mark Internal and private methods

+ (id<SUPReadWriteLockManager>)dblock
{
    return [[self instance] dblock];
}

+ (void)clearConnection
{
    [super clearConnection];
    [[self instance] setManager:nil];
}

+ (void)onMessage:(SUPJsonMessage*)message
{
    [[self instance] onMessage:message];
}

+ (id<SUPQueueConnection>)queueConnection
{
    return [[self instance] queueConnection];
}

+ (void)startBackgroundSynchronization
{
    [[self instance] startBackgroundSynchronization];
}

+ (void)stopBackgroundSynchronization
{
    [[self instance] stopBackgroundSynchronization];
}

- (void)createDatabase
{
	[[BFSMP_TesterDB delegate] createDatabase];
}

- (BOOL)checkPending_LogRecordImpl
{  
    return NO;
}
- (BOOL)checkPending_PackageProperties
{  
    return NO;
}
- (BOOL)checkAllReplayPending
{
    BOOL wait = NO;
    if (wait == NO) {    
        wait =[self checkPending_LogRecordImpl];
    }
    if (wait == NO) {    
        wait =[self checkPending_PackageProperties];
    }
    return wait;
}

- (NSString *)ppmHeader
{
    SUPJsonObject *json = [[SUPJsonObject alloc] init];
    SUPAbstractPersonalizationParameters *pp = [[BFSMP_TesterDB delegate] personalizationParameters];
        NSDictionary *keyMap = [pp getAllPersonalizationKeys];
    for (id keyName in [keyMap allKeys])
    {
        [json setNullableString:keyName:[keyMap objectForKey:keyName]];
    }    
    NSData *bin = [SUPStringUtil toUTF8:[json toString]];
    [json autorelease];
    return ([SUPBase64Encoding encode:bin]);
}

- (NSMutableDictionary*)getTableMBOMap
{
    NSMutableDictionary *map = [[[NSMutableDictionary alloc] init] autorelease];
    [map setObject:@"LST_MBO1" forKey:@"co_smp_tester_1_0_lst_mbo1"];;
    [map setObject:@"LogRecordImpl" forKey:@"smp_tester_1_0_logrecordimpl"];;
    [map setObject:@"OperationReplay" forKey:@"smp_tester_1_0_operationreplay"];;
    [map setObject:@"SISSubscription" forKey:@"sup_sis_subscription"];;
    [map setObject:@"PackageProperties" forKey:@"smp_tester_1_0_packageproperties"];;
    [map setObject:@"ChangeLogImpl" forKey:@"smp_tester_1_0_changelogimpl"];;
    [map setObject:@"OfflineAuthentication" forKey:@"co_smp_tester_1_0_offlineauthentication"];;
    [map setObject:@"KeyGenerator" forKey:@"smp_tester_1_0_keygenerator"];;
    [map setObject:@"LocalKeyGenerator" forKey:@"co_smp_tester_1_0_localkeygenerator"];;
    
    return map;
}

- (void)defineMessageListenerForEntity:(NSString*)entityName withClass:(Class)entityClass
{
    SUPEntityMessageListener* listener = [[SUPEntityMessageListener alloc] initWithClass:entityClass];
    [listener autorelease];
    [self.messageListenerMap add:(id)entityName:(id)listener];
}

- (NSObject<SUPQueueConnection>*)queueConnection
{
    if (_queueConnection == nil)
    {
        self.queueConnection = [SUPQueueConnectionImpl getInstance:self.connectionProfile withPackage:@"SMP_Tester:1.0"];
    }
    return _queueConnection;
}

+ (NSString*) getDbPath
{
    return [[self delegate] getDbPath];
}

@end